{"version":3,"sources":["/home/runner/work/storage/storage/packages/blob/dist/index.cjs","../src/del.ts","../src/head.ts","../src/list.ts","../src/copy.ts","../src/index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/storage/storage/packages/blob/dist/index.cjs","sourcesContent":[null,"import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions,\n): Promise<void> {\n  await requestApi(\n    '/delete',\n    {\n      method: 'POST',\n      headers: { 'content-type': 'application/json' },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n}\n","import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface HeadBlobResult {\n  url: string;\n  downloadUrl: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions,\n): Promise<HeadBlobResult> {\n  const searchParams = new URLSearchParams({ url });\n\n  const response = await requestApi<HeadBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: 'GET',\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt),\n  };\n}\n","import { requestApi } from './api';\nimport type { BlobCommandOptions } from './helpers';\n\nexport interface ListBlobResultBlob {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\nexport interface ListFoldedBlobResult extends ListBlobResult {\n  folders: string[];\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n  folders?: string[];\n}\n\nexport interface ListCommandOptions<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs that start with this prefix.\n   * If used together with `mode: 'folded'`, make sure to include a trailing slash after the foldername.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n  /**\n   * Defines how the blobs are listed\n   * - `expanded` the blobs property contains all blobs.\n   * - `folded` the blobs property contains only the blobs at the root level of your store. Blobs that are located inside a folder get merged into a single entry in the folder response property.\n   * @defaultvalue 'expanded'\n   */\n  mode?: M;\n}\n\ntype ListCommandResult<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n> = M extends 'folded' ? ListFoldedBlobResult : ListBlobResult;\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list<\n  M extends 'expanded' | 'folded' | undefined = undefined,\n>(options?: ListCommandOptions<M>): Promise<ListCommandResult<M>> {\n  const searchParams = new URLSearchParams();\n\n  if (options?.limit) {\n    searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    searchParams.set('cursor', options.cursor);\n  }\n  if (options?.mode) {\n    searchParams.set('mode', options.mode);\n  }\n\n  const response = await requestApi<ListBlobApiResponse>(\n    `?${searchParams.toString()}`,\n    {\n      method: 'GET',\n      signal: options?.abortSignal,\n    },\n    options,\n  );\n\n  if (options?.mode === 'folded') {\n    return {\n      folders: response.folders ?? [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult),\n    } as ListCommandResult<M>;\n  }\n\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult),\n  } as ListCommandResult<M>;\n}\n\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob,\n): ListBlobResultBlob {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n","import { MAXIMUM_PATHNAME_LENGTH, requestApi } from './api';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { BlobError, disallowedPathnameCharacters } from './helpers';\n\nexport type CopyCommandOptions = CommonCreateBlobOptions;\n\nexport interface CopyBlobResult {\n  url: string;\n  downloadUrl: string;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions,\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  if (toPathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`,\n    );\n  }\n\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (toPathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`,\n      );\n    }\n  }\n\n  const headers: Record<string, string> = {};\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const response = await requestApi<CopyBlobResult>(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    {\n      method: 'PUT',\n      headers,\n      signal: options.abortSignal,\n    },\n    options,\n  );\n\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n  };\n}\n","import type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\nimport { createCreateMultipartUploadMethod } from './multipart/create';\nimport type { UploadPartCommandOptions } from './multipart/upload';\nimport { createUploadPartMethod } from './multipart/upload';\nimport type { CompleteMultipartUploadCommandOptions } from './multipart/complete';\nimport { createCompleteMultipartUploadMethod } from './multipart/complete';\nimport type { CommonCreateBlobOptions } from './helpers';\nimport { createCreateMultipartUploaderMethod } from './multipart/create-uploader';\n\n// expose generic BlobError and download url util\nexport {\n  BlobError,\n  getDownloadUrl,\n  type OnUploadProgressCallback,\n  type UploadProgressEvent,\n} from './helpers';\n\n// expose api BlobErrors\nexport {\n  BlobAccessError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n  BlobServiceNotAvailable,\n  BlobRequestAbortedError,\n  BlobServiceRateLimited,\n  BlobContentTypeNotAllowedError,\n  BlobPathnameMismatchError,\n  BlobClientTokenExpiredError,\n  BlobFileTooLargeError,\n} from './api';\n\n// vercelBlob.put()\n\nexport type { PutBlobResult } from './put-helpers';\nexport type { PutCommandOptions };\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation forAclient uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to, including the extension. This will influence the url of your blob like https://$storeId.public.blob.vercel-storage.com/$pathname.\n * @param body - The content of your blob, can be a: string, File, Blob, Buffer or Stream. We support almost everything fetch supports: https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#body.\n * @param options - Additional options like `token` or `contentType`.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n//  vercelBlob.del()\n\nexport { del } from './del';\n\n// vercelBlob.head()\n\nexport type { HeadBlobResult } from './head';\nexport { head } from './head';\n\n// vercelBlob.list()\n\nexport type {\n  ListBlobResultBlob,\n  ListBlobResult,\n  ListCommandOptions,\n  ListFoldedBlobResult,\n} from './list';\nexport { list } from './list';\n\n// vercelBlob.copy()\n\nexport type { CopyBlobResult, CopyCommandOptions } from './copy';\nexport { copy } from './copy';\n\n// vercelBlob. createMultipartUpload()\n// vercelBlob. uploadPart()\n// vercelBlob. completeMultipartUpload()\n// vercelBlob. createMultipartUploader()\n\nexport const createMultipartUpload =\n  createCreateMultipartUploadMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport const createMultipartUploader =\n  createCreateMultipartUploaderMethod<CommonCreateBlobOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { UploadPartCommandOptions };\nexport const uploadPart = createUploadPartMethod<UploadPartCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\nexport type { CompleteMultipartUploadCommandOptions };\nexport const completeMultipartUpload =\n  createCompleteMultipartUploadMethod<CompleteMultipartUploadCommandOptions>({\n    allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n  });\n\nexport type { Part, PartInput } from './multipart/helpers';\n\nexport { createFolder } from './create-folder';\n"]}